package com.liugw.learn.jdbc;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.CallableStatementCreator;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.SqlInOutParameter;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.core.SqlReturnResultSet;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.jdbc.support.rowset.SqlRowSet;

public class JdbcTemplateTest {

	private static JdbcTemplate jdbcTemplate;

	@BeforeClass
	public static void setUpClass() {
		String url = "jdbc:hsqldb:mem:test";
		String username = "sa";
		String password = "";

		DriverManagerDataSource dataSource = new DriverManagerDataSource(url, username, password);
		dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
		jdbcTemplate = new JdbcTemplate(dataSource);
		System.out.println("BeforeClass ----- create dataSource");
	}

	@Test
	public void test() {
		// 1.声明SQL
		String sql = "select * from INFORMATION_SCHEMA.SYSTEM_TABLES";
		jdbcTemplate.query(sql, new RowCallbackHandler() {
			@Override
			public void processRow(ResultSet rs) throws SQLException {
				// 2.处理结果集
				String value = rs.getString("TABLE_NAME");
				System.out.println("Column TABLENAME:" + value);
			}
		});
	}

	// 在每个测试方法之前执行
	@Before
	public void setUp() {
		String createTableSql = "create memory table test" + "(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
				+ "name varchar(100))";
		System.out.println(createTableSql);
		jdbcTemplate.update(createTableSql);

		// 创建函数
		String createHsqldbFunctionSql = "CREATE FUNCTION FUNCTION_TEST(str CHAR(100)) " +
				"returns INT begin atomic return length(str);end";
		jdbcTemplate.update(createHsqldbFunctionSql);

		// 创建存储过程
		String createHsqldbProcedureSql = "CREATE PROCEDURE PROCEDURE_TEST" +
				"(INOUT inOutName VARCHAR(100), OUT outId INT) " +
				"MODIFIES SQL DATA " +
				"BEGIN ATOMIC " +
				"  insert into test(name) values (inOutName); " +
				"  SET outId = IDENTITY(); " +
				"  SET inOutName = 'Hello,' + inOutName; " +
				"END";
		jdbcTemplate.execute(createHsqldbProcedureSql);
	}

	// 在每个测试方法之后执行
	@After
	public void tearDown() {
		jdbcTemplate.execute("DROP FUNCTION FUNCTION_TEST");
		jdbcTemplate.execute("DROP PROCEDURE PROCEDURE_TEST");

		String dropTableSql = "drop table test";
		System.out.println(dropTableSql);
		jdbcTemplate.execute(dropTableSql);
	}

	@Test
	public void testCURD() {
		insert();
		delete();
		update();
		select();
	}

	private void insert() {
		jdbcTemplate.update("insert into test(name) values('name1')");
		jdbcTemplate.update("insert into test(name) values('name2')");
		jdbcTemplate.update("insert into test(name) values('jack1')");

		// Assert.assertEquals(3, jdbcTemplate.queryForInt("select count(*) from
		// test"));
		System.out.println("record_count= " + jdbcTemplate.queryForInt("select count(*) from test"));
	}

	private void delete() {
		jdbcTemplate.update("delete from test where name=?", new Object[] { "name2" });
		// Assert.assertEquals(1, jdbcTemplate.queryForInt("select count(*) from
		// test"));
	}

	@SuppressWarnings("deprecation")
	private void update() {
		jdbcTemplate.update("update test set name='name3' where name=?", new Object[] { "name1" });
		System.out.println("record count=" + jdbcTemplate.queryForInt("select count(*) from test where name='name3'"));
	}

	/**
	 * query结果集处理回调
	 * 
	 * @param args
	 */
	private void select() {
		jdbcTemplate.query("select * from test", new RowCallbackHandler() {

			@Override
			public void processRow(ResultSet rs) throws SQLException {
				// TODO Auto-generated method stub
				System.out.println("========== id=" + rs.getInt("id"));
				System.out.println("========== name=" + rs.getString("name"));
			}

		});
	}

	/***************
	 * ==================================================================================
	 * 首先使用PreparedStatementCreator创建一个预编译语句，其次由JdbcTemplate通过PreparedStatementCallback
	 * 回调传回，由用户决定如何执行该PreparedStatement。此处我们使用的是execute方法。
	 */
	@Test
	public void testPreparedStatement1() {
		int count = jdbcTemplate.execute(new PreparedStatementCreator() {
			@Override
			public PreparedStatement createPreparedStatement(Connection conn) throws SQLException {
				return conn.prepareStatement("select count(*) from test");
			}
		}, new PreparedStatementCallback<Integer>() {

			@Override
			public Integer doInPreparedStatement(PreparedStatement pstmt) throws SQLException, DataAccessException {
				pstmt.execute();
				ResultSet resultSet = pstmt.getResultSet();
				resultSet.next();

				return resultSet.getInt(1);
			}
		});
		System.out.println("count=" + count);
	}

	/**
	 * 通过JdbcTemplate的int update(String sql, PreparedStatementSetter
	 * pss)执行预编译sql，其中sql参数为“insert into test(name) values (?)
	 * ”，该sql有一个占位符需要在执行前设值，PreparedStatementSetter实现就是为了设值，使用setValues(PreparedStatement
	 * pstmt)回调方法设值相应的占位符位置的值。JdbcTemplate也提供一种更简单的方式“update(String sql,
	 * Object... args)”来实现设值，所以只要当使用该种方式不满足需求时才应使用PreparedStatementSetter。
	 */
	@Test
	public void testPreparedStatement2() {
		String insertSql = "insert into test(name) values (?)";
		int count = jdbcTemplate.update(insertSql, new PreparedStatementSetter() {

			@Override
			public void setValues(PreparedStatement pstmt) throws SQLException {
				pstmt.setObject(1, "Jack1");
			}

		});
		System.out.println("count=" + count);
	}

	/**
	 * 结果集处理回调1
	 * 
	 * RowMapper接口提供mapRow(ResultSet rs, int rowNum)方法将结果集的每一行转换为一个Map，
	 * 当然可以转换为其他类，如表的对象画形式。
	 * 
	 * @param args
	 */
	@Test
	public void testResultSet1() {
		jdbcTemplate.update("insert into test(name) values('mark1')");
		jdbcTemplate.update("insert into test(name) values('mark2')");
		String listSql = "select * from test";
		List result = jdbcTemplate.query(listSql, new RowMapper<Map>() {

			@Override
			public Map mapRow(ResultSet rs, int rownum) throws SQLException {
				Map row = new HashMap<>();
				row.put(rs.getInt("id"), rs.getString("name"));
				return row;
			}

		});
		System.out.println("row num=" + result.size());
	}

	/**
	 * 结果集处理回调2
	 * 
	 * RowCallbackHandler接口也提供方法processRow(ResultSet rs)，能将结果集的行转换为需要的形式。
	 * 
	 * @param args
	 */
	@Test
	public void testResultSet2() {
		jdbcTemplate.update("insert into test(name) values('mark1')");
		jdbcTemplate.update("insert into test(name) values('mark2')");
		String listSql = "select * from test";
		final List result = new ArrayList<>();
		jdbcTemplate.query(listSql, new RowCallbackHandler() {

			@Override
			public void processRow(ResultSet rs) throws SQLException {
				// TODO Auto-generated method stub
				Map row = new HashMap<>();
				row.put(rs.getInt("id"), rs.getString("name"));
				result.add(row);
			}

		});
		System.out.println("row num=" + result.size());
	}

	/**
	 * ResultSetExtractor使用回调方法extractData(ResultSet rs)
	 * 提供给用户整个结果集，让用户决定如何处理该结果集。
	 */
	@Test
	public void testResultSet3() {
		jdbcTemplate.update("insert into test(name) values('mark1')");
		jdbcTemplate.update("insert into test(name) values('mark2')");
		String listSql = "select * from test";
		final List result = jdbcTemplate.query(listSql, new ResultSetExtractor<List>() {

			@Override
			public List extractData(ResultSet rs) throws SQLException, DataAccessException {
				// TODO Auto-generated method stub
				List result = new ArrayList<>();
				while (rs.next()) {
					Map row = new HashMap<>();
					row.put(rs.getInt("id"), rs.getString("name"));
					result.add(row);
				}
				return result;
			}

		});
		System.out.println("row num=" + result.size());
	}

	/**
	 * JdbcTemplate提供更简单的queryForXXX方法，来简化开发：
	 * 
	 * @param args
	 */
	@Test
	public void testQueryForXXX() {
		jdbcTemplate.update("insert into test(name) values('mark1')");
		jdbcTemplate.update("insert into test(name) values('jack')");
		jdbcTemplate.update("insert into test(name) values('Hack')");

		// 1.查询一行数据并返回int型结果
		int r1 = jdbcTemplate.queryForInt("select count(*) from test");

		// 2. 查询一行数据并将该行数据转换为Map返回
		Map onerow = jdbcTemplate.queryForMap("select * from test where name='mark1'");
		System.out.println("name=" + onerow.get("name"));

		// 3.查询一行任何类型的数据，最后一个参数指定返回结果类型
		int r2 = jdbcTemplate.queryForObject("select count(*) from test", Integer.class);

		// 4.查询一批数据，默认将每行数据转换为Map
		List<Map<String, Object>> rows = jdbcTemplate.queryForList("select * from test");
		System.out.println("name2=" + rows.get(1).get("name"));

		// 5.只查询一列数据列表，列类型是String类型，列名字是name
		List<String> list = jdbcTemplate.queryForList("select name from test where name=?", new Object[] { "name5" },
				String.class);
		System.out.println("string=" + list.size());

		// 6.查询一批数据，返回为SqlRowSet，类似于ResultSet，但不再绑定到连接上
		SqlRowSet rs = jdbcTemplate.queryForRowSet("select * from test");
		rs.next();
		System.out.println(rs.getString("name"));

	}

	/**
	 * {call FUNCTION_TEST(?)}：定义自定义函数的sql语句，注意hsqldb {?= call …}和{call
	 * …}含义是一样的，而比如mysql中两种含义是不一样的；
	 * params：用于描述自定义函数占位符参数或命名参数类型；SqlParameter用于描述IN类型参数、SqlOutParameter用于描述OUT类型参数、SqlInOutParameter用于描述INOUT类型参数、SqlReturnResultSet用于描述调用存储过程或自定义函数返回的ResultSet类型数据，其中SqlReturnResultSet需要提供结果集处理回调用于将结果集转换为相应的形式，hsqldb自定义函数返回值是ResultSet类型。
	 * CallableStatementCreator：提供Connection对象用于创建CallableStatement对象
	 * outValues：调用call方法将返回类型为Map<String, Object>对象；
	 * outValues.get("result")：获取结果，即通过SqlReturnResultSet对象转换过的数据；其中SqlOutParameter、SqlInOutParameter、SqlReturnResultSet指定的name用于从call执行后返回的Map中获取相应的结果，即name是Map的键。
	 * 注：因为hsqldb {?= call …}和{call …}含义是一样的，因此调用自定义函数将返回一个包含结果的ResultSet。
	 */
	@Test
	public void testCallableStatementCreator1() {
		final String callFunctionSql = "{call FUNCTION_TEST(?)}";

		List<SqlParameter> params = new ArrayList<SqlParameter>();
		params.add(new SqlParameter(Types.VARCHAR));

		params.add(new SqlReturnResultSet("result",
				new ResultSetExtractor<Integer>() {
					@Override
					public Integer extractData(ResultSet rs) throws SQLException, DataAccessException {
						while (rs.next()) {
							System.out.println("reslut=" + rs.getInt(1));
							return rs.getInt(1);
						}
						return 0;
					}
				}));

		Map<String, Object> outValues = jdbcTemplate.call(
				new CallableStatementCreator() {
					@Override
					public CallableStatement createCallableStatement(Connection conn) throws SQLException {
						CallableStatement cstmt = conn.prepareCall(callFunctionSql);
						cstmt.setString(1, "test Hello World");
						return cstmt;
					}
				}, params);
		System.out.println(outValues.get("result"));
	}

	/**
	 * 获取mysql 数据源
	 * 
	 * @return
	 */
	public DataSource getMysqlDataSource() {
		String url = "jdbc:mysql://localhost:3306/taotao?serverTimezone=UTC";
		DriverManagerDataSource dataSource = new DriverManagerDataSource(url, "root", "root");
		dataSource.setDriverClassName("com.mysql.jdbc.Driver");
		return dataSource;
	}

	/**
	 * 执行 mysql 自定义函数
	 */
	@Test
	public void testCallableStatementCreator2() {
		JdbcTemplate mysqlJdbcTemplate = new JdbcTemplate(getMysqlDataSource());

		// 2.创建自定义函数
		String createFunctionSql = "CREATE FUNCTION FUNCTION_TEST(str VARCHAR(100)) " +
				"returns INT return LENGTH(str)";
		String dropFunctionSql = "DROP FUNCTION IF EXISTS FUNCTION_TEST";
		mysqlJdbcTemplate.update(dropFunctionSql); // 如果存在此函数，先删除。
		mysqlJdbcTemplate.update(createFunctionSql);

		// 3.准备sql,mysql支持{?= call …}
		final String callFunctionSql = "{?= call FUNCTION_TEST(?)}";

		// 4.定义参数
		List<SqlParameter> params = new ArrayList<SqlParameter>();
		params.add(new SqlOutParameter("result", Types.INTEGER));
		params.add(new SqlParameter("str", Types.VARCHAR));

		Map<String, Object> outValues = mysqlJdbcTemplate.call(
				new CallableStatementCreator() {
					@Override
					public CallableStatement createCallableStatement(Connection conn) throws SQLException {
						CallableStatement cstmt = conn.prepareCall(callFunctionSql);
						cstmt.registerOutParameter(1, Types.INTEGER);
						cstmt.setString(2, "test");
						return cstmt;
					}
				}, params);
		System.out.println("mysql function_result=" + outValues.get("result"));
	}

	/**
	 * 执行存储过程
	 * 
	 * {call PROCEDURE_TEST(?, ?)}：定义存储过程sql；
	 * params：定义存储过程参数；SqlInOutParameter描述INOUT类型参数、SqlOutParameter描述OUT类型参数；
	 * CallableStatementCreator：用于创建CallableStatement，并设值及注册OUT参数类型；
	 * outValues：通过SqlInOutParameter及SqlOutParameter参数定义的name来获取存储过程结果。
	 * 
	 */
	@Test
	public void testCallableStatementCreator3() {
		final String callProcedureSql = "{call PROCEDURE_TEST(?, ?)}";

		List<SqlParameter> params = new ArrayList<SqlParameter>();
		params.add(new SqlInOutParameter("inOutName", Types.VARCHAR));
		params.add(new SqlOutParameter("outId", Types.INTEGER));

		Map<String, Object> outValues = jdbcTemplate.call(
				new CallableStatementCreator() {
					@Override
					public CallableStatement createCallableStatement(Connection conn) throws SQLException {
						CallableStatement cstmt = conn.prepareCall(callProcedureSql);
						cstmt.registerOutParameter(1, Types.VARCHAR);
						cstmt.registerOutParameter(2, Types.INTEGER);
						cstmt.setString(1, "test");
						return cstmt;
					}
				}, params);
		System.out.println(outValues.get("inOutName"));
		System.out.println(outValues.get("outId"));
	}

	public static void main(String[] args) {
		JdbcTemplateTest templateTest = new JdbcTemplateTest();
		JdbcTemplateTest.setUpClass();
		templateTest.test();

		templateTest.testCallableStatementCreator2();
	}
}
