package com.liugw.learn.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.jdbc.object.SqlUpdate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

public class SimpleJdbcInsertTest {
	private static JdbcTemplate jdbcTemplate;

	@BeforeClass
	public static void setUpClass() {
		String url = "jdbc:hsqldb:mem:test";
		String username = "sa";
		String password = "";

		DriverManagerDataSource dataSource = new DriverManagerDataSource(url, username, password);
		dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
		jdbcTemplate = new JdbcTemplate(dataSource);
		System.out.println("BeforeClass ----- create dataSource");
	}

	// 在每个测试方法之前执行
	@Before
	public void setUp() {
		String createTableSql = "create memory table test" + "(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
				+ "name varchar(100))";
		System.out.println(createTableSql);
		jdbcTemplate.update(createTableSql);

		// 创建函数
		String createHsqldbFunctionSql = "CREATE FUNCTION FUNCTION_TEST(str CHAR(100)) " +
				"returns INT begin atomic return length(str);end";
		jdbcTemplate.update(createHsqldbFunctionSql);

		// 创建存储过程
		String createHsqldbProcedureSql = "CREATE PROCEDURE PROCEDURE_TEST" +
				"(INOUT inOutName VARCHAR(100), OUT outId INT) " +
				"MODIFIES SQL DATA " +
				"BEGIN ATOMIC " +
				"  insert into test(name) values (inOutName); " +
				"  SET outId = IDENTITY(); " +
				"  SET inOutName = 'Hello,' + inOutName; " +
				"END";
		jdbcTemplate.execute(createHsqldbProcedureSql);
	}

	// 在每个测试方法之后执行
	@After
	public void tearDown() {
		jdbcTemplate.execute("DROP FUNCTION FUNCTION_TEST");
		jdbcTemplate.execute("DROP PROCEDURE PROCEDURE_TEST");

		String dropTableSql = "drop table test";
		System.out.println(dropTableSql);
		jdbcTemplate.execute(dropTableSql);
	}

	@Test
	public void testSimpleJdbcInsert() {
		// 首次通过DataSource对象或JdbcTemplate对象初始化SimpleJdbcInsert
		SimpleJdbcInsert insert = new SimpleJdbcInsert(jdbcTemplate);
		// 用于设置数据库表名
		insert.withTableName("test");

		// 用于指定插入时列名及值，如本例中只有name列名，即编译后的sql类似于“insert into test(name)
		// values(?)”
		Map<String, Object> args = new HashMap<String, Object>();
		args.put("name", "name5");

		// 可选的编译步骤，在调用执行方法时自动编译，编译后不能再对insert对象修改
		insert.compile();

		// 1.普通插入
		insert.execute(args);
		System.out.println(jdbcTemplate.queryForInt("select count(*) from test"));

		// 2.插入时获取主键值
		insert = new SimpleJdbcInsert(jdbcTemplate);
		insert.withTableName("test");
		// 必须首先通过setGeneratedKeyName设置主键然后才能获取，如果想获取复合主键请使用setGeneratedKeyNames
		// 描述主键然后通过executeReturningKeyHolder获取复合主键KeyHolder对象
		insert.setGeneratedKeyName("id");
		Number id = insert.executeAndReturnKey(args);
		id = insert.executeAndReturnKey(args);
		System.out.println("id=" + id);

		// 3.批处理
		insert = new SimpleJdbcInsert(jdbcTemplate);
		insert.withTableName("test");
		insert.setGeneratedKeyName("id");
		int[] updateCount = insert.executeBatch(new Map[] { args, args, args });

		System.out.println(updateCount[0]);
		System.out.println(jdbcTemplate.queryForInt("select count(*) from test"));
	}

	/**
	 * JdbcTemplate 获取自动生成主键方式, (KeyHolder)
	 * 
	 * @throws SQLException
	 */
	@Test
	public void testFetchKey1() throws SQLException {
		final String insertSql = "insert into test(name) values('name5')";
		KeyHolder generatedKeyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(new PreparedStatementCreator() {
			@Override
			public PreparedStatement createPreparedStatement(Connection conn)
					throws SQLException {
				return conn.prepareStatement(insertSql, new String[] { "ID" });
			}
		}, generatedKeyHolder);

		jdbcTemplate.update(new PreparedStatementCreator() {
			@Override
			public PreparedStatement createPreparedStatement(Connection conn)
					throws SQLException {
				return conn.prepareStatement(insertSql, new String[] { "ID" });
			}
		}, generatedKeyHolder);
		System.out.println(generatedKeyHolder.getKey());
	}

	@Test
	public void testFetchKey2() {
		final String insertSql = "insert into test(name) values('name5')";
		KeyHolder generatedKeyHolder = new GeneratedKeyHolder();
		SqlUpdate update = new SqlUpdate();
		update.setJdbcTemplate(jdbcTemplate);
		update.setReturnGeneratedKeys(true);
		// update.setGeneratedKeysColumnNames(new String[]{"ID"});
		update.setSql(insertSql);
		update.update(null, generatedKeyHolder);
		System.out.println(generatedKeyHolder.getKey());
	}
}
